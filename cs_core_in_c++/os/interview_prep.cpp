// | #      | Topic                                   | Why Important                                                           | Key Concepts / Focus                                                                                                                                        |
// | ------ | --------------------------------------- | ----------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | **1**  | **Processes & Threads**                 | Core of multitasking; concurrency reasoning is often tested             | Process vs Thread, PCB, Context switching, Thread lifecycle, User vs Kernel threads, Multi-threaded design, Pros/cons of threads                            |
// | **2**  | **Synchronization & Concurrency**       | Directly tests ability to reason about shared resources and correctness | Mutex, Semaphore, Locks, Deadlocks, Race Conditions, Critical Sections, Producer-Consumer, Readers-Writers, Dining Philosophers, Condition Variables        |
// | **3**  | **CPU Scheduling & Multitasking**       | Evaluates understanding of performance and fairness under load          | FCFS, SJF, Priority, Round Robin, Multilevel Queue, Preemption, Starvation, Throughput, Response Time                                                       |
// | **4**  | **Deadlocks & Resource Management**     | Frequently scenario-based; tests reasoning under constraints            | Necessary & Sufficient conditions, Resource Allocation Graph, Deadlock prevention/avoidance, Banker's Algorithm, Livelock vs Deadlock                       |
// | **5**  | **Memory Management & Virtual Memory**  | High relevance for low-level system design questions                    | Paging, Segmentation, Virtual Memory, TLB, Page Tables, Multi-level Paging, Page Replacement Algorithms (LRU, LFU, Clock, FIFO, Optimal), Fragmentation     |
// | **6**  | **File Systems & I/O Management**       | Important for understanding storage, buffering, and system performance  | File descriptors, File metadata, Open/close/read/write semantics, Disk scheduling (FCFS, SSTF, SCAN), Caching/Buffering, I/O bottlenecks                    |
// | **7**  | **Inter-Process Communication (IPC)**   | Tests concurrency and distributed system reasoning                      | Pipes, Message Queues, Shared Memory, Sockets, Signals, Race conditions in IPC, Synchronization between processes                                           |
// | **8**  | **System Calls & Kernel vs User Space** | Shows understanding of OS abstractions and boundaries                   | Privilege levels, Context switching, How programs request OS services, System call mechanism, Interrupts, Traps                                             |
// | **9**  | **Performance & Profiling Basics**      | Often tested implicitly through reasoning/problem-solving questions     | Cache hierarchy, Memory hierarchy, Page faults, Context switch overhead, CPU utilization, Latency vs Throughput                                             |
// | **10** | **OS Design Patterns & Trade-offs**     | Tests reasoning about real-world system design and trade-offs           | Trade-offs between paging vs segmentation, Thread vs Process, Synchronization strategies, Memory allocation policies, I/O strategies, Scheduling heuristics |
