# Operating System Concepts Prep

## Features / Requirements:

- [ ] **Processes & Threads**
    - **Why Important**: Core of multitasking; concurrency reasoning is often tested
    - [ ] Process vs Thread
    - [ ] PCB (Process Control Block)
    - [ ] Context switching
    - [ ] Thread lifecycle
    - [ ] User vs Kernel threads
    - [ ] Multi-threaded design
    - [ ] Pros/cons of threads

- [ ] **Synchronization & Concurrency**
    - **Why Important**: Directly tests ability to reason about shared resources and correctness
    - [ ] Mutex
    - [ ] Semaphore
    - [ ] Locks
    - [ ] Deadlocks
    - [ ] Race Conditions
    - [ ] Critical Sections
    - [ ] Producer-Consumer
    - [ ] Readers-Writers
    - [ ] Dining Philosophers
    - [ ] Condition Variables

- [ ] **CPU Scheduling & Multitasking**
    - **Why Important**: Evaluates understanding of performance and fairness under load
    - [ ] FCFS (First-Come, First-Served)
    - [ ] SJF (Shortest Job First)
    - [ ] Priority Scheduling
    - [ ] Round Robin
    - [ ] Multilevel Queue Scheduling
    - [ ] Preemption
    - [ ] Starvation
    - [ ] Throughput
    - [ ] Response Time

- [ ] **Deadlocks & Resource Management**
    - **Why Important**: Frequently scenario-based; tests reasoning under constraints
    - [ ] Necessary & Sufficient conditions for deadlock
    - [ ] Resource Allocation Graph
    - [ ] Deadlock prevention/avoidance
    - [ ] Banker's Algorithm
    - [ ] Livelock vs Deadlock

- [ ] **Memory Management & Virtual Memory**
    - **Why Important**: High relevance for low-level system design questions
    - [ ] Paging
    - [ ] Segmentation
    - [ ] Virtual Memory
    - [ ] TLB (Translation Lookaside Buffer)
    - [ ] Page Tables
    - [ ] Multi-level Paging
    - [ ] Page Replacement Algorithms (LRU, LFU, Clock, FIFO, Optimal)
    - [ ] Fragmentation

- [ ] **File Systems & I/O Management**
    - **Why Important**: Important for understanding storage, buffering, and system performance
    - [ ] File descriptors
    - [ ] File metadata
    - [ ] Open/close/read/write semantics
    - [ ] Disk scheduling (FCFS, SSTF, SCAN)
    - [ ] Caching/Buffering
    - [ ] I/O bottlenecks

- [ ] **Inter-Process Communication (IPC)**
    - **Why Important**: Tests concurrency and distributed system reasoning
    - [ ] Pipes
    - [ ] Message Queues
    - [ ] Shared Memory
    - [ ] Sockets
    - [ ] Signals
    - [ ] Race conditions in IPC
    - [ ] Synchronization between processes

- [ ] **System Calls & Kernel vs User Space**
    - **Why Important**: Shows understanding of OS abstractions and boundaries
    - [ ] Privilege levels
    - [ ] Context switching
    - [ ] How programs request OS services
    - [ ] System call mechanism
    - [ ] Interrupts
    - [ ] Traps

- [ ] **Performance & Profiling Basics**
    - **Why Important**: Often tested implicitly through reasoning/problem-solving questions
    - [ ] Cache hierarchy
    - [ ] Memory hierarchy
    - [ ] Page faults
    - [ ] Context switch overhead
    - [ ] CPU utilization
    - [ ] Latency vs Throughput

- [ ] **OS Design Patterns & Trade-offs**
    - **Why Important**: Tests reasoning about real-world system design and trade-offs
    - [ ] Trade-offs between paging vs segmentation
    - [ ] Thread vs Process
    - [ ] Synchronization strategies
    - [ ] Memory allocation policies
    - [ ] I/O strategies
    - [ ] Scheduling heuristics
